## VaR calculation programs
#  These are the steps we are planning on taking :
# Get inputs regarding calculations of the timeframe
#  Read the positions dataframe
#  Calculate daily returns dataframe from the closing prices
#  Create a vector and in each row store result of multiplication position row
#  with returns rows for timeframe specified
#  Sort the vector and get 95% worst PNL
# Repeat the procedure for each day and positions and get worst PNL of the days **


import pandas as pd
import numpy as np
import os
import datetime
import logging

multipliers = {"1YM": 5, "DM": 100, "ES": 50, "FCE": 10, "FDX": 25,
                "FF": 4167, "FV": 1200, "NQ": 20, "RMF": 50, "STXE": 10,
                "TFS": 50, "TN": 1000,  "TU": 2000, "TY": 1000, "US": 1000,
                "AUDUSD": 1, "EURGBP": 0, "EURJPY": 0,"EURUSD": 1, "GBPUSD": 1,
                "USDCAD": -1, "USDCHF": -1, "USDJPY": -1, "CL":1000, "LCO":1000}

'''multipliers = {"1YM": 5, "DM": 100, "ES": 50, "FCE": 10, "FDX": 25,
                "FF": 4167, "FV": 1200, "NQ": 20, "RMF": 50, "STXE": 10,
                "TFS": 50, "TN": 1000,  "TU": 2000, "TY": 1000, "US": 1000,
                "USDAUD=R": -1, "EURGBP=R": 0, "EURJPY=R": 0,"USDEUR=R": -1, "USDGBP=R": -1,
                "CADUSD": -1, "CHFUSD": -1, "JPYUSD": -1, "CL":1000, "LCO":1000}'''
''' 1D_Resample files  need to be copied from copied from 1 Time Live  output  so reversing done '''

'''multipliers = {"1YM": 5, "DM": 100, "ES": 50, "FCE": 10, "FDX": 25,
                "FF": 4167, "FV": 1200, "NQ": 20, "RMF": 50, "STXE": 10,
                "TFS": 50, "TN": 1000,  "TU": 2000, "TY": 1000, "US": 1000,
                "USDAUD=R": 1, "EURGBP=R": 0, "EURJPY=R": 0,"USDEUR=R": 1, "USDGBP=R": 1,
                "CADUSD=R": 1, "CHFUSD=R": 1, "JPYUSD=R": 1, "CL":1000, "LCO":1000}'''

def get_arguments():
    """
    This function initializes the args to specify the inputs :
    :return: args data structure
    """
    import argparse
    parser = argparse.ArgumentParser(description="VaR  Script")
    parser.add_argument('-p', '--positionFile', default='/big/VARinputs/ML/Backtests/openPositionMaster.csv',help="position file location")

    vartype = parser.add_mutually_exclusive_group(required=True)
    vartype.add_argument('-w', '--window', type=int,
                         help="Rolling window of calendar days to be considered when calculating VaR")
    vartype. add_argument('-s', '--startdate', type=lambda d: datetime.datetime.strptime (d,'%Y%m%d'), help = 'Start Date as YYYYMMDD to be considered when calculating VaR')
    parser.add_argument('-e', '--enddate', type=lambda d: datetime.datetime.strptime(d, '%Y%m%d'),
                            help = 'End Date as YYYYMMDD to be considered when calculating VaR')
    parser.add_argument("-l", "--log", dest="logLevel", default="INFO",
                        choices = ['DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'],
                        help = "Set the logging level")
    # args = parser.parse_args ("-d 20170101".split(" "))

    # Added by US
    parser.add_argument('-pdf', '--pdf', default='C:/MyProjects/Master/VaR-pricesDF.txt', help="VaR-pricesDF file ")
    parser.add_argument('-rdf', '--rdf', default='C:/MyProjects/Master/VaR-returnsDF.txt', help="VaR-returnDF file ")
    parser.add_argument('-dfInput', '--dfInput', action='store_true', help="if param provided use dfinput")
    parser.add_argument('-baseOut', '--baseOutDir', default='/big/VARinputs/ML/Backtests/', help="base output Directory")

    # parser.print_help()
    args = parser.parse_args()
    return args

def get_positions(file):
    '''Function to read the positions generated by simulator
    :param file: location of the csv
    :return: positions dataframe'''

    pos = pd.read_csv(file).set_index('t')
    #pos = pd.read_csv(file,nrows=10).set_index('D')
    return pos

def get_returns():
    """ Calculate normal returns from closing prices
    :return: returns dataframe"""
    #data_path = '/big/VARinputs/data/'
    data_path = '/home/lanarayan/MLData'
    prices = pd.DataFrame(columns=multipliers.keys())

    for types in os.listdir(data_path):
        type_path = os.path.join(data_path, types)
        #temp change :LN Nov 27, 2018  to accomodate lack stable of historical data process
        if types == "FX":
            type_path = '/big/VARinputs/data/FX/BacktestData'
        elif types == "Futures":
            type_path = os.path.join(type_path, 'Live')
        else:
            continue
        if os.path.isdir(type_path):
            for instrument in os.listdir(type_path):
                instruments_path = os.path.join(type_path, instrument)
                daily_path = os.path.join(instruments_path, '1D_resampleTest.csv' if types == "FX" else '1D_resample.csv')
                print("reading ", daily_path)
                if os. path.exists(daily_path):
                    inst_price = pd.read_csv(daily_path)
                    prices = prices.join(inst_price[['D', 'LSTP']].set_index('D'),how = 'outer')
                    prices = prices.drop([instrument], axis = 1)
                    prices = prices.rename(columns={'LSTP': instrument})
                else:
                    print("path not found  ", daily_path)                

    prices = prices.fillna(method= 'ffill')
    #Banku maybe print message if there are duplicates
    prices = prices.fillna(0).drop_duplicates()

    ret = (prices.shift(-1) -prices)/prices
    ret = ret.fillna(0)

    return prices,ret

def calculate_total_var(pos, prices, ret, window, startdate, enddate):
    '''
    Calculate VaR of the portfolio by looking at worst VaR for any position
    : param    pos: position    dataframe.Will    iterate    of    this    dataframe and calculate    VaR    for each
    : param    prices: closing    prices    dataframe    for calculating notional
    : param    ret: returns    dataframe
    : param    window: look - back    window    for 95th percentile
    : return: VaR    of    the    portfolio
    '''

    var = pd.DataFrame(columns={'pnl'},index = pos.index)
    for index, position in pos.iterrows():
        pnl = calculate_pos_var(position,prices,ret, window, startdate, enddate)
        var.loc[position.name] = pnl

    return var


def calculate_pos_var(position,prices,ret,history_window, startdate, enddate):
    ''' Given position vector, calculate VaR for those positions
    :param position: positions dataframe
    :param prices: prices dataframe
    :param ret; returns dataframe
    :param history_window: look-back window for 95th %
    :return: Var for the given position
'''
    if position.name not in ret.index:
        return 0

    idx = ret.index.get_loc(position.name)
    
    print("Processing :", position.name)
    logging.debug("Processing :%s"%position.name)

    if startdate != None:
        try:
            start = ret.index.get_loc(startdate.strftime("%Y-%m-%d"))
            if enddate != None:
                try:
                    idx = ret.index.get_loc(enddate.strftime("%Y-%m-%d"))
                except KeyError:
                    logging.critical("Specified end date %s does not exist in the data" %enddate.strftime("%Y%m%d"))
                    exit()
        except KeyError:
            logging.critical("Specified start date %s does not exist in the data" % startdate.strftime("%Y%m%d"))
            exit()

    elif idx< history_window:
        start = 0
    else:
         start = idx - history_window

    position = position[ret.columns].replace(np.nan,0)
    pnl=[]

    for day in range(idx, start, -1):
        #print("Calculating daily pnl for date ",ret.iloc[day].name)
        logging.debug("\tCalculating daily pnl for date %s"%ret.iloc[day].name)
        if day >= 0:
            daily_pnl = 0
            for inst in multipliers:
                if multipliers[inst] == 0:
                    #daily_pnl += (position[inst] * prices.iloc[day][inst] * ret.iloc[day][inst] * prices.iloc[day]['EURUSD'])
                    # revert when multipliers restored to =R format
                    # daily_pnl += (position[inst] * ret.iloc[day][inst] * prices.iloc[day]['USDEUR=R'])
                    daily_pnl += (position[inst] * ret.iloc[day][inst] * prices.iloc[day]['EURUSD'])
                    if (position[inst] > 0):
                        logging.debug("Position Greater than Zero")
                        logging.debug("Date {}, day {}, inst {}, posval {},price {}, return {}, multi {}".format(position.name,day,inst,  position[inst],prices.iloc[day][inst],ret.iloc[day][inst],multipliers[inst]))
                        logging.debug("pnl {}".format(daily_pnl))
                elif multipliers[inst] == -1:
                    if prices.iloc[day][inst] != 0:
                        daily_pnl += (position[inst]
                                      * ret.iloc[day][inst] / prices.iloc[day][inst])
                else:
                    daily_pnl += (position[inst]
                                    * prices.iloc[day][inst]
                                    * ret.iloc[day][inst]
                                    * multipliers[inst])
                    if(position[inst] > 0):
                        logging.debug("Position Greater than Zero")
                        logging.debug("Date {}, day {}, inst {}, posval {},price {}, return {}, multi {}".format(position.name,day,inst,position[inst], prices.iloc[day][inst],ret.iloc[day][inst],multipliers[inst]))
                        logging.debug("pnl {}".format(daily_pnl))
            pnl.append(daily_pnl)

    #logging.debug("PNL Length %s"%len(pnl))

    #print (position.name ," -PNL greater than 0: ",any(x > 0 for x in pnl))
    #logging.debug("Total pnl for date {} is {}".format(position.name,daily_pnl))
    pnl.sort()
    if len(pnl) != 0:
        return pnl[round(len(pnl) * 5 / 100)]
    else:
        #logging.debug("PNL 0")
        return 0


def main():
    args = get_arguments()
    logging.basicConfig(filename='VaRAnalysisNewLog.log', filemode='w',level=getattr(logging, args.logLevel), format='%(asctime)s %(levelname)s %(message)s')

    if not os.path.exists(args.baseOutDir):
        print("Creating output folder :" + args.baseOutDir)
        os.makedirs(args.baseOutDir)
    pos = get_positions(args.positionFile)
    if args.dfInput:
        prices = pd.read_csv(args.pdf,index_col='D')
        ret = pd.read_csv(args.rdf,index_col='D')
    else:
        prices,ret = get_returns()

    prices.to_csv(os.path.join(args.baseOutDir, 'PricesVar.csv'), index=True)
    ret.to_csv(os.path.join(args.baseOutDir, 'ReturnVar.csv'), index=True)
    #var = calculate_total_var(pos,prices,ret,args.days)
    print(args.startdate, args.enddate)
    var = calculate_total_var(pos, prices, ret, args.window, args.startdate, args.enddate)
    
    var.to_csv(os.path.join(args.baseOutDir, 'RiskMgmtVaRReport.csv'), index=True)
    VaRValue = var.sort_values('pnl').iloc[0,0]
    print("VaR of the portfolio: ", var.sort_values('pnl').iloc[0,0])
    # output -p and var value
    fhLog = open(os.path.join(args.baseOutDir, 'VaRReport.txt'), 'a')
    fhLog.write(args.positionFile + "," +  str(VaRValue) + "\n")
    logging.info("VaR of the portfolio : %f" % var.sort_values('pnl').iloc[0, 0])

    '''args = get_arguments()
    logging.basicConfig(level=getattr(logging, args.logLevel), format='% (asctime)s %(levelname) s % (message)s')
    pos = get_positions(args.positionFile)
    prices, ret = get_returns()
    var = calculate_total_var(pos, prices, ret, args.window, args.startdate, args.enddate)
    logging.info("VaR of the portfolio : %f" % var.sort_values('pnl').iloc[0, 0])'''


main()



